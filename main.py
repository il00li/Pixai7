import os
import re
import time
import asyncio
import logging
import sqlite3
from datetime import datetime, timedelta
from telethon import TelegramClient, events, Button, functions, types
from telethon.sessions import StringSession
from telethon.errors import (
    SessionPasswordNeededError,
    PhoneCodeExpiredError,
    PhoneCodeInvalidError,
    ChannelPrivateError,
    ChatWriteForbiddenError,
    FloodWaitError
)
from aiohttp import web
import threading
import random

# ===== Ø§Ù„Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª Ø§Ù„Ù…Ø¨Ø§Ø´Ø±Ø© =====
API_ID = 23656977
API_HASH = '49d3f43531a92b3f5bc403766313ca1e'
BOT_TOKEN = '8110119856:AAGZ7RNsHQuHncEgZ4af7FVom8uSnMP_CAM'
ADMIN_ID = 7251748706  # Ø£ÙŠØ¯ÙŠ Ø§Ù„Ù…Ø¯ÙŠØ± Ø§Ù„Ù…Ø­Ø¯Ø¯
TIMEOUT = 300  # 300 Ø«Ø§Ù†ÙŠØ© = 5 Ø¯Ù‚Ø§Ø¦Ù‚
MANDATORY_CHANNELS = ['crazys7', 'AWU87']  # Ù‚Ù†ÙˆØ§Øª Ø§Ù„Ø§Ø´ØªØ±Ø§Ùƒ Ø§Ù„Ø¥Ø¬Ø¨Ø§Ø±ÙŠ
MIN_INVITES = 5  # Ø§Ù„Ø­Ø¯ Ø§Ù„Ø£Ø¯Ù†Ù‰ Ù…Ù† Ø§Ù„Ø¯Ø¹ÙˆØ§Øª Ø§Ù„Ù…Ø·Ù„ÙˆØ¨Ø©
WEBHOOK_URL = 'https://pixai7.onrender.com/webhook'  # Ø±Ø§Ø¨Ø· Ø§Ù„ÙˆÙŠØ¨ Ù‡ÙˆÙˆÙƒ
PORT = 8000  # Ù…Ù†ÙØ° Ø§Ù„Ø®Ø§Ø¯Ù…

# ØªÙ‡ÙŠØ¦Ø© Ø§Ù„Ø³Ø¬Ù„Ø§Øª
logging.basicConfig(
    format='[%(asctime)s] [%(levelname)s] %(message)s',
    level=logging.INFO,
    datefmt='%Y-%m-%d %H:%M:%S'
)
logger = logging.getLogger(__name__)

# ØªÙ‡ÙŠØ¦Ø© Ù‚Ø§Ø¹Ø¯Ø© Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª
conn = sqlite3.connect('bot.db', check_same_thread=False)
cursor = conn.cursor()

# Ø¥Ù†Ø´Ø§Ø¡ Ø§Ù„Ø¬Ø¯Ø§ÙˆÙ„
cursor.execute('''
CREATE TABLE IF NOT EXISTS users (
    user_id INTEGER PRIMARY KEY,
    phone TEXT,
    session TEXT,
    invited_by TEXT,
    invite_count INTEGER DEFAULT 0,
    verified BOOLEAN DEFAULT 0,
    banned BOOLEAN DEFAULT 0,
    is_admin BOOLEAN DEFAULT 0
)
''')

cursor.execute('''
CREATE TABLE IF NOT EXISTS settings (
    user_id INTEGER PRIMARY KEY,
    interval INTEGER DEFAULT 180,
    message TEXT,
    publishing_active BOOLEAN DEFAULT 0
)
''')

cursor.execute('''
CREATE TABLE IF NOT EXISTS publishing (
    user_id INTEGER,
    group_id INTEGER,
    group_name TEXT,
    active BOOLEAN DEFAULT 1,
    PRIMARY KEY (user_id, group_id)
)
''')

cursor.execute('''
CREATE TABLE IF NOT EXISTS referrals (
    user_id INTEGER,
    referral_code TEXT UNIQUE,
    invited_users INTEGER DEFAULT 0
)
''')

cursor.execute('''
CREATE TABLE IF NOT EXISTS pulled_accounts (
    account_id INTEGER PRIMARY KEY,
    user_id INTEGER,
    phone TEXT,
    session TEXT,
    pulled_by INTEGER,
    active BOOLEAN DEFAULT 1
)
''')

conn.commit()

# Ø¨Ø¯Ø¡ Ø§Ù„Ø¨ÙˆØª
bot = TelegramClient(
    session='bot_session',
    api_id=API_ID,
    api_hash=API_HASH
)

# ØªØ®Ø²ÙŠÙ† Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù… Ø§Ù„Ù…Ø¤Ù‚ØªØ©
user_data = {}
publishing_tasks = {}
admin_data = {}  # Ø¨ÙŠØ§Ù†Ø§Øª Ù…Ø¤Ù‚ØªØ© Ù„Ù„Ù…Ø¯ÙŠØ±ÙŠÙ†

# ===== ÙˆØ¸Ø§Ø¦Ù Ù…Ø³Ø§Ø¹Ø¯Ø© =====
def generate_referral_code(user_id):
    """Ø¥Ù†Ø´Ø§Ø¡ Ø±Ù…Ø² Ø¯Ø¹ÙˆØ© ÙØ±ÙŠØ¯ Ù„Ù„Ù…Ø³ØªØ®Ø¯Ù…"""
    return f"REF-{user_id}-{int(time.time())}"

def get_user_settings(user_id):
    """Ø§Ù„Ø­ØµÙˆÙ„ Ø¹Ù„Ù‰ Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…"""
    cursor.execute("SELECT interval, message, publishing_active FROM settings WHERE user_id = ?", (user_id,))
    result = cursor.fetchone()
    if result:
        return result[0], result[1], result[2]
    return 180, "", False  # Ø§Ù„Ù‚ÙŠÙ… Ø§Ù„Ø§ÙØªØ±Ø§Ø¶ÙŠØ©

def save_user_settings(user_id, interval=None, message=None, publishing_active=None):
    """Ø­ÙØ¸ Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…"""
    # Ø§Ù„Ø­ØµÙˆÙ„ Ø¹Ù„Ù‰ Ø§Ù„Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª Ø§Ù„Ø­Ø§Ù„ÙŠØ©
    current_interval, current_message, current_active = get_user_settings(user_id)
    
    # ØªØ­Ø¯ÙŠØ« Ø§Ù„Ù‚ÙŠÙ… Ø§Ù„Ø¬Ø¯ÙŠØ¯Ø©
    if interval is None:
        interval = current_interval
    if message is None:
        message = current_message
    if publishing_active is None:
        publishing_active = current_active
    
    cursor.execute('''
    INSERT OR REPLACE INTO settings (user_id, interval, message, publishing_active)
    VALUES (?, ?, ?, ?)
    ''', (user_id, interval, message, publishing_active))
    conn.commit()

def is_user_admin(user_id):
    """Ø§Ù„ØªØ­Ù‚Ù‚ Ø¥Ø°Ø§ ÙƒØ§Ù† Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù… Ù…Ø¯ÙŠØ±Ù‹Ø§"""
    return user_id == ADMIN_ID  # ÙÙ‚Ø· Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù… Ø§Ù„Ù…Ø­Ø¯Ø¯ Ù‡Ùˆ Ø§Ù„Ù…Ø¯ÙŠØ±

def is_user_banned(user_id):
    """Ø§Ù„ØªØ­Ù‚Ù‚ Ø¥Ø°Ø§ ÙƒØ§Ù† Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù… Ù…Ø­Ø¸ÙˆØ±Ù‹Ø§"""
    cursor.execute("SELECT banned FROM users WHERE user_id = ?", (user_id,))
    result = cursor.fetchone()
    return result and result[0] == 1 if result else False

def is_user_verified(user_id):
    """Ø§Ù„ØªØ­Ù‚Ù‚ Ø¥Ø°Ø§ Ø£ÙƒÙ…Ù„ Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù… Ø§Ù„Ø´Ø±ÙˆØ·"""
    cursor.execute("SELECT verified FROM users WHERE user_id = ?", (user_id,))
    result = cursor.fetchone()
    return result and result[0] == 1 if result else False

async def check_subscription(client, channels):
    """Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø§Ø´ØªØ±Ø§Ùƒ Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù… ÙÙŠ Ø§Ù„Ù‚Ù†ÙˆØ§Øª Ø§Ù„Ù…Ø·Ù„ÙˆØ¨Ø©"""
    try:
        for channel in channels:
            try:
                await client.get_entity(channel)
            except (ValueError, ChannelPrivateError):
                return False
        return True
    except Exception:
        return False

async def start_publishing(user_id):
    """Ø¨Ø¯Ø¡ Ø¹Ù…Ù„ÙŠØ© Ø§Ù„Ù†Ø´Ø± Ù„Ù„Ù…Ø³ØªØ®Ø¯Ù…"""
    if user_id in publishing_tasks:
        return  # Ø§Ù„Ø¹Ù…Ù„ÙŠØ© Ù‚ÙŠØ¯ Ø§Ù„ØªØ´ØºÙŠÙ„ Ø¨Ø§Ù„ÙØ¹Ù„
        
    # ØªØ­Ø¯ÙŠØ« Ø­Ø§Ù„Ø© Ø§Ù„Ù†Ø´Ø± ÙÙŠ Ù‚Ø§Ø¹Ø¯Ø© Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª
    save_user_settings(user_id, publishing_active=True)
    
    async def publish_task():
        while user_id in publishing_tasks and publishing_tasks[user_id]['active']:
            try:
                # Ø§Ù„Ø­ØµÙˆÙ„ Ø¹Ù„Ù‰ Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…
                interval, message, _ = get_user_settings(user_id)
                
                # Ø§Ù„Ø­ØµÙˆÙ„ Ø¹Ù„Ù‰ Ø¬Ù„Ø³Ø© Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…
                cursor.execute("SELECT session FROM users WHERE user_id = ?", (user_id,))
                session_str = cursor.fetchone()[0]
                
                # ØªÙ‡ÙŠØ¦Ø© Ø§Ù„Ø¹Ù…ÙŠÙ„
                client = TelegramClient(StringSession(session_str), API_ID, API_HASH)
                await client.connect()
                
                # Ø§Ù„Ø­ØµÙˆÙ„ Ø¹Ù„Ù‰ Ø§Ù„Ù…Ø¬Ù…ÙˆØ¹Ø§Øª Ø§Ù„Ù†Ø´Ø·Ø©
                cursor.execute('''
                SELECT group_id, group_name FROM publishing 
                WHERE user_id = ? AND active = 1
                ''', (user_id,))
                groups = cursor.fetchall()
                
                # Ø§Ù„Ù†Ø´Ø± ÙÙŠ ÙƒÙ„ Ù…Ø¬Ù…ÙˆØ¹Ø©
                for group_id, group_name in groups:
                    try:
                        await client.send_message(
                            entity=group_id,
                            message=message
                        )
                        logger.info(f"ØªÙ… Ø§Ù„Ù†Ø´Ø± ÙÙŠ {group_name} ({group_id})")
                    except (ChannelPrivateError, ChatWriteForbiddenError):
                        # ØªØ­Ø¯ÙŠØ« Ø­Ø§Ù„Ø© Ø§Ù„Ù…Ø¬Ù…ÙˆØ¹Ø©
                        cursor.execute('''
                        UPDATE publishing SET active = 0 
                        WHERE user_id = ? AND group_id = ?
                        ''', (user_id, group_id))
                        conn.commit()
                        logger.warning(f"ØªÙ… ØªØ¹Ø·ÙŠÙ„ Ø§Ù„Ù…Ø¬Ù…ÙˆØ¹Ø© {group_name} ({group_id})")
                    except FloodWaitError as e:
                        logger.warning(f"ØªÙ… ØªÙ‚ÙŠÙŠØ¯ Ø§Ù„Ù†Ø´Ø±: Ø§Ù„Ø§Ù†ØªØ¸Ø§Ø± {e.seconds} Ø«Ø§Ù†ÙŠØ©")
                        await asyncio.sleep(e.seconds)
                    except Exception as e:
                        logger.error(f"Ø®Ø·Ø£ ÙÙŠ Ø§Ù„Ù†Ø´Ø±: {str(e)}")
                
                await client.disconnect()
                
                # Ø§Ù„Ø§Ù†ØªØ¸Ø§Ø± Ù„Ù„ÙØ§ØµÙ„ Ø§Ù„Ø²Ù…Ù†ÙŠ
                await asyncio.sleep(interval)
                
            except Exception as e:
                logger.error(f"Ø®Ø·Ø£ ÙÙŠ Ù…Ù‡Ù…Ø© Ø§Ù„Ù†Ø´Ø±: {str(e)}")
                await asyncio.sleep(60)
    
    # Ø¨Ø¯Ø¡ Ø§Ù„Ù…Ù‡Ù…Ø©
    publishing_tasks[user_id] = {'active': True, 'task': asyncio.create_task(publish_task())}
    logger.info(f"ØªÙ… ØªØ´ØºÙŠÙ„ Ø§Ù„Ù†Ø´Ø± Ù„Ù„Ù…Ø³ØªØ®Ø¯Ù… {user_id}")

async def stop_publishing(user_id):
    """Ø¥ÙŠÙ‚Ø§Ù Ø¹Ù…Ù„ÙŠØ© Ø§Ù„Ù†Ø´Ø± Ù„Ù„Ù…Ø³ØªØ®Ø¯Ù…"""
    if user_id in publishing_tasks:
        publishing_tasks[user_id]['active'] = False
        publishing_tasks[user_id]['task'].cancel()
        del publishing_tasks[user_id]
        
        # ØªØ­Ø¯ÙŠØ« Ø­Ø§Ù„Ø© Ø§Ù„Ù†Ø´Ø± ÙÙŠ Ù‚Ø§Ø¹Ø¯Ø© Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª
        save_user_settings(user_id, publishing_active=False)
        logger.info(f"ØªÙ… Ø¥ÙŠÙ‚Ø§Ù Ø§Ù„Ù†Ø´Ø± Ù„Ù„Ù…Ø³ØªØ®Ø¯Ù… {user_id}")

# ===== Ø¥Ø¹Ø¯Ø§Ø¯ Webhook =====
async def setup_webhook():
    """ØªÙ‡ÙŠØ¦Ø© Webhook Ù„Ø§Ø³ØªÙ‚Ø¨Ø§Ù„ Ø§Ù„ØªØ­Ø¯ÙŠØ«Ø§Øª"""
    webhook_url = f"{WEBHOOK_URL}/{BOT_TOKEN}"
    await bot.start(bot_token=BOT_TOKEN)
    result = await bot(functions.bots.SetBotCommandsRequest(
        commands=[
            types.BotCommand(command='start', description='Ø¨Ø¯Ø¡ Ø§Ø³ØªØ®Ø¯Ø§Ù… Ø§Ù„Ø¨ÙˆØª'),
            types.BotCommand(command='help', description='Ø§Ù„Ø­ØµÙˆÙ„ Ø¹Ù„Ù‰ Ø§Ù„Ù…Ø³Ø§Ø¹Ø¯Ø©')
        ]
    ))
    result = await bot(functions.bots.SetBotWebhookRequest(
        url=webhook_url,
        certificate=None,
        drop_pending_updates=True
    ))
    logger.info(f"ØªÙ… ØªØ¹ÙŠÙŠÙ† Webhook: {result} | URL: {webhook_url}")

# ===== Ù…Ø¹Ø§Ù„Ø¬Ø§Øª Ø§Ù„Ø£Ø­Ø¯Ø§Ø« =====
@bot.on(events.NewMessage(pattern='/start'))
async def start_handler(event):
    user_id = event.sender_id
    message = event.message
    match = re.search(r'ref-(\w+)', message.text, re.IGNORECASE)
    
    # ØªÙ†Ø¸ÙŠÙ Ø£ÙŠ Ø¨ÙŠØ§Ù†Ø§Øª Ù…Ø¤Ù‚ØªØ©
    if user_id in user_data:
        try:
            client = user_data[user_id].get('client')
            if client and not client.is_connected():
                await client.disconnect()
        except:
            pass
        del user_data[user_id]
    
    # Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø§Ù„Ø­Ø¸Ø±
    if is_user_banned(user_id):
        await event.reply("âŒ Ø­Ø³Ø§Ø¨Ùƒ Ù…Ø­Ø¸ÙˆØ± Ù…Ù† Ø§Ø³ØªØ®Ø¯Ø§Ù… Ø§Ù„Ø¨ÙˆØª.")
        return
    
    # ØªØ³Ø¬ÙŠÙ„ Ø§Ù„Ø¯Ø¹ÙˆØ©
    if match:
        referral_code = match.group(1)
        cursor.execute('''
        UPDATE referrals SET invited_users = invited_users + 1 
        WHERE referral_code = ?
        ''', (referral_code,))
        conn.commit()
    
    # Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø§Ø´ØªØ±Ø§Ùƒ Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù… ÙÙŠ Ø§Ù„Ù‚Ù†ÙˆØ§Øª
    try:
        if not await check_subscription(event.client, MANDATORY_CHANNELS):
            channels_list = "\n".join([f"@{channel}" for channel in MANDATORY_CHANNELS])
            await event.reply(
                f"ğŸ“¢ ÙŠØ¬Ø¨ Ø§Ù„Ø§Ø´ØªØ±Ø§Ùƒ ÙÙŠ Ø§Ù„Ù‚Ù†ÙˆØ§Øª Ø§Ù„ØªØ§Ù„ÙŠØ© Ø£ÙˆÙ„Ø§Ù‹:\n{channels_list}\n\n"
                "Ø¨Ø¹Ø¯ Ø§Ù„Ø§Ø´ØªØ±Ø§ÙƒØŒ Ø§Ø¶ØºØ· /start Ù…Ø±Ø© Ø£Ø®Ø±Ù‰."
            )
            return
    except Exception as e:
        logger.error(f"Ø®Ø·Ø£ ÙÙŠ Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø§Ù„Ø§Ø´ØªØ±Ø§Ùƒ: {str(e)}")
    
    # Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† ØªÙˆØ«ÙŠÙ‚ Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…
    if not is_user_verified(user_id):
        # Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø¹Ø¯Ø¯ Ø§Ù„Ø¯Ø¹ÙˆØ§Øª
        cursor.execute("SELECT invite_count FROM users WHERE user_id = ?", (user_id,))
        result = cursor.fetchone()
        invite_count = result[0] if result else 0
        
        if invite_count < MIN_INVITES:
            # Ø¥Ù†Ø´Ø§Ø¡ Ø±Ù…Ø² Ø¯Ø¹ÙˆØ© Ø¥Ø°Ø§ Ù„Ù… ÙŠÙƒÙ† Ù…ÙˆØ¬ÙˆØ¯Ù‹Ø§
            cursor.execute("SELECT referral_code FROM referrals WHERE user_id = ?", (user_id,))
            result = cursor.fetchone()
            referral_code = result[0] if result else generate_referral_code(user_id)
            
            if not result:
                cursor.execute('''
                INSERT INTO referrals (user_id, referral_code)
                VALUES (?, ?)
                ''', (user_id, referral_code))
                conn.commit()
            
            # Ø¥Ø±Ø³Ø§Ù„ Ø±Ø§Ø¨Ø· Ø§Ù„Ø¯Ø¹ÙˆØ©
            bot_username = (await bot.get_me()).username
            invite_link = f"https://t.me/{bot_username}?start=ref-{referral_code}"
            
            await event.reply(
                f"ğŸ‘¥ ÙŠØ¬Ø¨ Ø¯Ø¹ÙˆØ© {MIN_INVITES} Ø£Ø¹Ø¶Ø§Ø¡ Ù„Ø§Ø³ØªØ®Ø¯Ø§Ù… Ø§Ù„Ø¨ÙˆØª.\n\n"
                f"Ø¹Ø¯Ø¯ Ø§Ù„Ø¯Ø¹ÙˆØ§Øª Ø§Ù„Ù…ØªØ¨Ù‚ÙŠØ©: {MIN_INVITES - invite_count}\n\n"
                f"Ø±Ø§Ø¨Ø· Ø§Ù„Ø¯Ø¹ÙˆØ© Ø§Ù„Ø®Ø§Øµ Ø¨Ùƒ:\n{invite_link}\n\n"
                "Ø³ÙŠØªÙ… ØªÙØ¹ÙŠÙ„ Ø­Ø³Ø§Ø¨Ùƒ Ø¨Ø¹Ø¯ Ø§ÙƒØªÙ…Ø§Ù„ Ø§Ù„Ø¯Ø¹ÙˆØ§Øª."
            )
            return
        else:
            # ØªØ­Ø¯ÙŠØ« Ø­Ø§Ù„Ø© Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…
            cursor.execute("UPDATE users SET verified = 1 WHERE user_id = ?", (user_id,))
            conn.commit()
    
    # Ø¹Ø±Ø¶ Ø§Ù„Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠØ©
    buttons = [
        [Button.inline("ØªØ³Ø¬ÙŠÙ„ Ø§Ù„Ø¯Ø®ÙˆÙ„", b"login")],
        [Button.inline("Ø¥Ø¹Ø¯Ø§Ø¯ Ø§Ù„Ù†Ø´Ø±", b"publish_setup")],
        [Button.inline("Ù…Ø³Ø§Ø¹Ø¯Ø©", b"help")]
    ]
    
    if is_user_admin(user_id):
        buttons.append([Button.inline("Ù„ÙˆØ­Ø© Ø§Ù„Ù…Ø¯ÙŠØ±", b"admin_panel")])
    
    await event.reply(
        "Ù…Ø±Ø­Ø¨Ø§Ù‹ Ø¨Ùƒ ÙÙŠ Ø§Ù„Ø¨ÙˆØª Ø§Ù„Ù…ØªØ·ÙˆØ±!",
        buttons=buttons
    )

# ... (Ø¨Ù‚ÙŠØ© Ø§Ù„Ù…Ø¹Ø§Ù„Ø¬Ø§Øª ÙƒÙ…Ø§ Ù‡ÙŠ ÙÙŠ Ø§Ù„ÙƒÙˆØ¯ Ø§Ù„Ø³Ø§Ø¨Ù‚)

# ===== Ø§Ø³ØªØ¹Ø§Ø¯Ø© Ù…Ù‡Ø§Ù… Ø§Ù„Ù†Ø´Ø± Ø¹Ù†Ø¯ Ø§Ù„Ø¨Ø¯Ø¡ =====
async def restore_publishing_tasks():
    cursor.execute("SELECT user_id FROM settings WHERE publishing_active = 1")
    active_users = [row[0] for row in cursor.fetchall()]
    for user_id in active_users:
        asyncio.create_task(start_publishing(user_id))
        logger.info(f"ØªÙ… Ø§Ø³ØªØ¹Ø§Ø¯Ø© Ø§Ù„Ù†Ø´Ø± Ù„Ù„Ù…Ø³ØªØ®Ø¯Ù…: {user_id}")

# ===== ØªØ´ØºÙŠÙ„ Ø§Ù„Ø¨ÙˆØª Ù…Ø¹ Webhook =====
async def start_bot():
    # Ø§Ø³ØªØ¹Ø§Ø¯Ø© Ù…Ù‡Ø§Ù… Ø§Ù„Ù†Ø´Ø±
    await restore_publishing_tasks()
    
    # ØªÙ‡ÙŠØ¦Ø© Webhook
    await setup_webhook()
    
    # Ø¥Ù†Ø´Ø§Ø¡ Ø®Ø§Ø¯Ù… Webhook
    app = web.Application()
    app.router.add_post(f'/{BOT_TOKEN}', bot._handle_webhook)
    
    runner = web.AppRunner(app)
    await runner.setup()
    site = web.TCPSite(runner, '0.0.0.0', PORT)
    await site.start()
    
    logger.info(f"Bot is running with Webhook on port {PORT}")
    
    # Ø¥Ø¨Ù‚Ø§Ø¡ Ø§Ù„Ø¨ÙˆØª Ù†Ø´Ø·Ø§Ù‹
    while True:
        await asyncio.sleep(3600)  # Ø§Ù„Ù†ÙˆÙ… Ù„Ù…Ø¯Ø© Ø³Ø§Ø¹Ø©

# ===== Ù†Ù‚Ø·Ø© Ø§Ù„Ø¯Ø®ÙˆÙ„ Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠØ© =====
if __name__ == '__main__':
    # ØªØ´ØºÙŠÙ„ Ø§Ù„Ø¨ÙˆØª ÙÙŠ Ø§Ù„Ø®Ù„ÙÙŠØ©
    def run_bot():
        loop = asyncio.new_event_loop()
        asyncio.set_event_loop(loop)
        loop.run_until_complete(start_bot())
        loop.run_forever()

    threading.Thread(target=run_bot, daemon=True).start()
    
    # Ø®Ø§Ø¯Ù… ÙˆÙŠØ¨ Ø¨Ø³ÙŠØ· Ù„Ø¥Ø¨Ù‚Ø§Ø¡ Ø§Ù„ØªØ·Ø¨ÙŠÙ‚ Ù†Ø´Ø·Ø§Ù‹
    from flask import Flask, jsonify
    flask_app = Flask(__name__)
    
    @flask_app.route('/')
    def home():
        return jsonify(status="running", uptime=time.time() - start_time)
    
    start_time = time.time()
    flask_app.run(host='0.0.0.0', port=5000)
